map <Space>cv :call SetTitle()<CR>
func SetTitle()
	if &filetype == 'go'
		let l = 0
		let l = l + 1 | call setline(l,'package main')
		let l = l + 1 | call setline(l,'import ("bufio";"fmt";"io";"os";"strconv")')
		let l = l + 1 | call setline(l,'func main(){')
		let l = l + 1 | call setline(l,'	defer ot.Flush()')
		let l = l + 1 | call setline(l,'')
		let l = l + 1 | call setline(l,'}')
		let l = l + 1 | call setline(l,'/* ======================================================================== */')
		let l = l + 1 | call setline(l,'//')
		let l = l + 1 | call setline(l,'//')
		let l = l + 1 | call setline(l,'//')
		let l = l + 1 | call setline(l,'//							 _____   _   _   ____')
		let l = l + 1 | call setline(l,'//							| ____| | \ | | |  _ \')
		let l = l + 1 | call setline(l,'//							|  _|   |  \| | | | | |')
		let l = l + 1 | call setline(l,'//							| |___  | |\  | | |_| |')
		let l = l + 1 | call setline(l,'//							|_____| |_| \_| |____/')
		let l = l + 1 | call setline(l,'//')
		let l = l + 1 | call setline(l,'//')
		let l = l + 1 | call setline(l,'//')
		let l = l + 1 | call setline(l,'/* ============================PART1: I/O ================================== */')
		let l = l + 1 | call setline(l,'')
		let l = l + 1 | call setline(l,'/* ==== G0 ===== */')
		let l = l + 1 | call setline(l,'const BUFSIZE = int(1e6)')
		let l = l + 1 | call setline(l,'var (')
		let l = l + 1 | call setline(l,'	ot = bufio.NewWriterSize(os.Stdout, BUFSIZE)')
		let l = l + 1 | call setline(l,'	in = newScanner(os.Stdin)')
		let l = l + 1 | call setline(l,')')
		let l = l + 1 | call setline(l,'type scanner struct{ sc *bufio.Scanner }')
		let l = l + 1 | call setline(l,'func newScanner(input io.Reader) *scanner {sc := bufio.NewScanner(input);sc.Split(bufio.ScanWords);sc.Buffer(make([]byte, 1024), int(1e9));return &scanner{sc}}')
		let l = l + 1 | call setline(l,'')
		let l = l + 1 | call setline(l,'/* ==== G1 ===== */')
		let l = l + 1 | call setline(l,'func rnS() string  { in.sc.Scan(); return in.sc.Text() }')
		let l = l + 1 | call setline(l,'func rnI() int     { i, _ := strconv.Atoi(rnS()); return i }')
		let l = l + 1 | call setline(l,'func rnF() float64 { f, _ := strconv.ParseFloat(rnS(), 64); return f }')
		let l = l + 1 | call setline(l,'')
		let l = l + 1 | call setline(l,'/* ==== G2 ===== */')
		let l = l + 1 | call setline(l,'func rsI(n int) []int {t := make([]int, n);for i := 0; i < n; i++ {t[i] = rnI()};return t}')
		let l = l + 1 | call setline(l,'func rsF(n int) []float64 {t := make([]float64, n);for i := 0; i < n; i++ {t[i] = rnF()};return t}')
		let l = l + 1 | call setline(l,'func rsS(n int) []string {t := make([]string, n);for i := 0; i < n; i++ {t[i] = rnS()};return t}')
		let l = l + 1 | call setline(l,'')
		let l = l + 1 | call setline(l,'')
		let l = l + 1 | call setline(l,'/* ===========================PART 2: Math Func ============================  */')
		let l = l + 1 | call setline(l,'func max(x, y int) int {if x > y {return x};return y}')
		let l = l + 1 | call setline(l,'func abs(x int) int {if x > 0 {return x};return -x}')
		let l = l + 1 | call setline(l,'func min(x, y int) int {if x < y {return x};return y}')
		let l = l + 1 | call setline(l,'func memset(a []int, v int) {if len(a) == 0 {return};a[0] = v;for bp := 1; bp < len(a); bp *= 2 {copy(a[bp:], a[:bp])}}')
		let l = l + 1 | call setline(l,'')
		let l = l + 1 | call setline(l,'')
	endif
endfunc

